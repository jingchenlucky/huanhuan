# 迭代器和可迭代协议

解决副作用的redux中间件
redux-thunk:需要改动action，可接受action是一个异步函数
redux-promise:需要改动action,可接受action是一个promise对象，或者action的payload是一个promise对象
以上两个中间件，会导致action或者action创建函数不再纯净

redux-saga将解决这样的问题，它不仅可以保持action，action创建函数，reducer的纯净，而且可以用模块化的方式解决副作用，并且功能非常强大
redux-saga是建立在ES6生成器基础上的，要熟练使用saga,必须理解生成器。要理解生成器，必须先理解迭代器呵可迭代协议。

## 迭代
类似于遍历
遍历：有多个数据组成的集合数据结构(map/set/array等其它类数组),需要从该结构中依次取出数据进行某种处理

迭代：按照某种逻辑，依次取出下一个数据进行处理。

所有能进行遍历等类数组可以进行迭代，但是能进行迭代的数据不一定能遍历
遍历是对现成的数据操作，迭代器是要一个生成一个数据

## 迭代器
Js语言规定，如果一个对象有next方法，并且这个方法满足一定的约束。则该对象是一个迭代器(iterator)

next方法的约束：该方法必须返回一个对象，该对象必须有两个属性：
- value:any类型，下一个数据的值。如果done属性为true，通常将value设置为undefined
- done：bool类型，是否迭代完成。
通过迭代器的next方法，可以依次取出数据，并可以根据返回的done属性，判定迭代是否完成

### 迭代器创建函数 iterator creator
它是指一个函数，调用过之后，返回一个迭代器，则该函数称为迭代器创建函数，可以简称迭代函数

## 可迭代协议
ES6中出现了for-of循环。该循环是用来迭代对象的，因此，for-of循环要求对象必须是可迭代的（对象必须满足可迭代协议）

可迭代协议约束如下：
1.对象必须有一个知名符号属性Symbol.iterator
2.该属性必须是无参数的迭代器创建函数

### for-of实现原理
调用对象的[Symbol.iterator]方法，得到一个迭代器。不断调用next方法，只有返回的done为false，则将返回的value传递给变量，然后进入循环体执行一次。
