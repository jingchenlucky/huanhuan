#context

上下文：表示做某些事情的环境

React上下文特点
1 当某个组件创建了上下文后，上下文中的所有数据，都会被所有的后代组件共享
2 如果某个组件依赖了上下文，会导致该组件不再纯粹（之前的组件外部数据只来源于属性props，内部数据来源于状态state，就非常纯粹）
3 一般情况下，用于第三方组件（通用组件）

##旧API
**创建上下文**
只有类组件可以创建上下文(函数组件只可获取上下文数据)
1 给类组件书写静态属性childContextTypes,使用该属性对上下文中的数据类型进行约束
2 添加实例方法getChildContext(在props和state发生改变时，都会重新调用该函数),该方法返回的对象，即为上下文中的数据，该数据必须满足类型约束。该方法会在render之后调用

**使用上下文中的数据**
要求：如果要使用上下文中的数据，组件必须有一个静态属性contexttypes,该属性描述了需要获取的上下文中的数据类型
1 可以在组件构造函数中，通过第二个参数，获取上下文数据.由于构造函数只会运行一次，上下文数据改变后，获取到的数据不会更新。所以，通常不采用这种方式
2 **从组件的context属性中获取**
3 在函数组件中，通过第二个参数，获取上下文数据

**上下文中数据变化**
上下文中数据不可直接变化，最终都是通过状态改变

**父组件改变上下文**
OldContext中状态改变，重新调用getChildContext函数，上下文中数据改变，ChildA/ChildB得到的上下文数据更新
**子组件改变上下文，只需改变上下文中提供的方法**
在上下文中加入一个处理函数，用于更改后代组件更改上下文中数据

OldContext(创建上下文) -> ChildA -> ChildB

OldContext(创建上下文) -> ChildA(创建上下文) -> ChildB
ChildA拿到的上下文数据是OldContext的，她不会拿到自己上下文中的数据。
ChildB拿到的上下文数据是ChildA，即最近上下文数据

##新API
旧版本API存在严重的效率问题，容易出现滥用

NewContext(创建上下文) -> Provider -> ChidlA -> ChildB
**创建上下文**
上下文是一个独立于组件的对象，该对象通过React.createContext()创建。可以为其传餐设置默认值
返回的是一个包含两个属性的对象
1 Provider属性：(生产者)一个组件，该组件会创建一个上下文。该组件有一个value属性，通过该属性为其数据赋值
   （1）同一个Provider，不要用到多个组件中，如果需要在其他组件中使用该数据，应该考虑将数据提升至更高的层次
2 Consumer属性
**使用上下文**
1 在类组件中，直接使用this.context获取上下文
    要求：必须拥有静态属性contextType，应赋值为创建的上下文对象
2 在函数组件中，需要使用Consumer来获取上下文数据（类组件中也可以使用Consumer的方式，但函数组件不能用上面但方法）
    （1）Consumer是一个组件
    （2）它的子节点，是一个函数(它的props.children需要传递一个函数)
    
    
**注意细节**
如果，上下文提供者(Context.Provider)中的value属性发生变化(Object.is比较，地址比较，即使是空对象之间的变化，也是更新了，因为地址不一样)
会导致该上下文提供者的所有后代元素全部重新渲染，无论子元素是否有优化（无论子元素shouldComponentUpdate返回true/false,都会强制重新渲染）
